#include "System/Drivers/I2C/System_I2C.h"
#include "Si5351.h"

#define SI5351_I2C_ADDRESS	0x60

#define SI5351A_REVB_REG_CONFIG_NUM_REGS				61

enum si5351_pll Si5351__pll_assignment[8];

typedef struct
 {
 	unsigned int address; /* 16-bit register address */
 	unsigned char value; /* 8-bit register data */

 } si5351a_revb_register_t;


 //Note!   This was manually edited after being generated by Clock Generator Pro.

 //Register 9 was keeping the clocks from being active .   We are making sure they are always active.

 si5351a_revb_register_t const si5351a_revb_registers[SI5351A_REVB_REG_CONFIG_NUM_REGS] =
 {
 	{ 0x0002, 0x53 },
 	{ 0x0007, 0x01 },
 	{ 0x0009, 0xFF },
 	{ 0x000A, 0xF8 },
 	{ 0x000C, 0x00 },
 	{ 0x000D, 0x00 },
 	{ 0x000F, 0x00 },
 	{ 0x0010, 0x0F },
 	{ 0x0011, 0x0F },
 	{ 0x0012, 0x8C },
 	{ 0x0013, 0x8C },
 	{ 0x0014, 0x8C },
 	{ 0x0015, 0x8C },
 	{ 0x0016, 0x8C },
 	{ 0x0017, 0x8C },
 	{ 0x001A, 0x02 },
 	{ 0x001B, 0xA3 },
 	{ 0x001C, 0x00 },
 	{ 0x001D, 0x0E },
 	{ 0x001E, 0xA9 },
 	{ 0x001F, 0x00 },
 	{ 0x0020, 0x02 },
 	{ 0x0021, 0x65 },
 	{ 0x002A, 0x00 },
 	{ 0x002B, 0x04 },
 	{ 0x002C, 0x01 },
 	{ 0x002D, 0xB5 },
 	{ 0x002E, 0x60 },
 	{ 0x002F, 0x00 },
 	{ 0x0030, 0x00 },
 	{ 0x0031, 0x00 },
 	{ 0x0032, 0x00 },
 	{ 0x0033, 0x02 },
 	{ 0x0034, 0x03 },
 	{ 0x0035, 0x6C },
 	{ 0x0036, 0xC0 },
 	{ 0x0037, 0x00 },
 	{ 0x0038, 0x00 },
 	{ 0x0039, 0x00 },
 	{ 0x005A, 0x00 },
 	{ 0x005B, 0x00 },
 	{ 0x0095, 0x00 },
 	{ 0x0096, 0x00 },
 	{ 0x0097, 0x00 },
 	{ 0x0098, 0x00 },
 	{ 0x0099, 0x00 },
 	{ 0x009A, 0x00 },
 	{ 0x009B, 0x00 },
 	{ 0x00A2, 0x00 },
 	{ 0x00A3, 0x00 },
 	{ 0x00A4, 0x00 },
 	{ 0x00B7, 0xD2 },

 };

 /*
 si5351a_revb_register_t const si5351a_revb_registers[SI5351A_REVB_REG_CONFIG_NUM_REGS] =
 {
 	{ 0x0002, 0x53 },
 	{ 0x0003, 0x04 },
 	{ 0x0007, 0x01 },
 	{ 0x0009, 0xFF },
 	{ 0x000A, 0xF8 },
 	{ 0x000C, 0x00 },
 	{ 0x000D, 0x00 },
 	{ 0x000F, 0x00 },
 	{ 0x0010, 0x0F },
 	{ 0x0011, 0x0F },
 	{ 0x0012, 0x8F },
 	{ 0x0013, 0x8C },
 	{ 0x0014, 0x8C },
 	{ 0x0015, 0x8C },
 	{ 0x0016, 0x8C },
 	{ 0x0017, 0x8C },
 	{ 0x001A, 0x0D },
 	{ 0x001B, 0x2F },
 	{ 0x001C, 0x00 },
 	{ 0x001D, 0x0E },
 	{ 0x001E, 0xA6 },
 	{ 0x001F, 0x00 },
 	{ 0x0020, 0x03 },
 	{ 0x0021, 0x86 },
 	{ 0x002A, 0x00 },
 	{ 0x002B, 0x04 },
 	{ 0x002C, 0x00 },
 	{ 0x002D, 0x34 },
 	{ 0x002E, 0xE0 },
 	{ 0x002F, 0x00 },
 	{ 0x0030, 0x00 },
 	{ 0x0031, 0x00 },
 	{ 0x0032, 0x00 },
 	{ 0x0033, 0x01 },
 	{ 0x0034, 0x03 },
 	{ 0x0035, 0x6C },
 	{ 0x0036, 0x00 },
 	{ 0x0037, 0x00 },
 	{ 0x0038, 0x00 },
 	{ 0x0039, 0x00 },
 	{ 0x003A, 0x00 },
 	{ 0x003B, 0x01 },
 	{ 0x003C, 0x01 },
 	{ 0x003D, 0xB5 },
 	{ 0x003E, 0x00 },
 	{ 0x003F, 0x00 },
 	{ 0x0040, 0x00 },
 	{ 0x0041, 0x00 },
 	{ 0x005A, 0x00 },
 	{ 0x005B, 0x00 },
 	{ 0x0095, 0x00 },
 	{ 0x0096, 0x00 },
 	{ 0x0097, 0x00 },
 	{ 0x0098, 0x00 },
 	{ 0x0099, 0x00 },
 	{ 0x009A, 0x00 },
 	{ 0x009B, 0x00 },
 	{ 0x00A2, 0x00 },
 	{ 0x00A3, 0x00 },
 	{ 0x00A4, 0x00 },
 	{ 0x00B7, 0xD2 },

 };*/

 /*
  * Design Report
  *
  * Overview
  * ========
  * Part:         Si5351A Rev B
  * Project File: C:\ELI\ADFP-GIT\acoustic_detection_node\CONFIG\Si5361 - Clock Gen\Si5361 - Clock Gen.slabtimeproj
  * Created By:   ClockBuilder Pro v2.13 [2017-03-03]
  * Timestamp:    2017-03-19 17:06:41 GMT-04:00
  *
  * Design Rule Check
  * =================
  * Errors:
  * - No errors
  *
  * Warnings:
  * - No warnings
  *
  * Design
  * ======
  * Inputs:
  *     IN0: 27 MHz
  *
  * Outputs:
  *    OUT0: 1.024 MHz [ 1 + 3/125 MHz ]
  *          Enabled LVCMOS 8 mA
  *          Offset 0.000 s
  *    OUT1: 512 kHz
  *          Enabled LVCMOS 8 mA
  *          Offset 0.000 s
  *    OUT2: Unused
  *
  * Frequency Plan
  * ==============
  * PLL_A:
  *    Enabled Features = None
  *    Fvco             = 899.84 MHz [ 899 + 21/25 MHz ]
  *    M                = 33.3274074074074074... [ 33 + 221/675 ]
  *    Input0:
  *       Source           = Crystal
  *       Source Frequency = 27 MHz
  *       Fpfd             = 27 MHz
  *       Load Capacitance = Load_10pF
  *    Output0:
  *       Features       = None
  *       Disabled State = StopLow
  *       R              = 1  (2^0)
  *       Fout           = 1.024 MHz [ 1 + 3/125 MHz ]
  *       N              = 878.75 [ 878 + 3/4 ]
  *    Output1:
  *       Features       = None
  *       Disabled State = StopLow
  *       R              = 1  (2^0)
  *       Fout           = 512 kHz
  *       N              = 1757.5 [ 1757 + 1/2 ]
  *
  * Settings
  * ========
  *
  * Location      Setting Name       Decimal Value  Hex Value
  * ------------  -----------------  -------------  ---------
  * 0x0002[3]     XO_LOS_MASK        0              0x0
  * 0x0002[4]     CLK_LOS_MASK       1              0x1
  * 0x0002[5]     LOL_A_MASK         0              0x0
  * 0x0002[6]     LOL_B_MASK         1              0x1
  * 0x0002[7]     SYS_INIT_MASK      0              0x0
  * 0x0007[7:4]   I2C_ADDR_CTRL      0              0x0
  * 0x0009[7:0]   OEB_MASK0          248            0xF8
  * 0x000A[7:0]   OEB_MASK1          248            0xF8
  * 0x000C[7:0]   SLAB_FRQSEL0_CTRL  0              0x00
  * 0x000C[11:4]  SLAB_FRQSEL1_CTRL  0              0x00
  * 0x000F[2]     PLLA_SRC           0              0x0
  * 0x000F[3]     PLLB_SRC           0              0x0
  * 0x000F[4]     PLLA_INSELB        0              0x0
  * 0x000F[5]     PLLB_INSELB        0              0x0
  * 0x000F[7:6]   CLKIN_DIV          0              0x0
  * 0x0010[1:0]   CLK0_IDRV          3              0x3
  * 0x0010[3:2]   CLK0_SRC           3              0x3
  * 0x0010[4]     CLK0_INV           0              0x0
  * 0x0010[5]     MS0_SRC            0              0x0
  * 0x0010[6]     MS0_INT            0              0x0
  * 0x0010[7]     CLK0_PDN           0              0x0
  * 0x0011[1:0]   CLK1_IDRV          3              0x3
  * 0x0011[3:2]   CLK1_SRC           3              0x3
  * 0x0011[4]     CLK1_INV           0              0x0
  * 0x0011[5]     MS1_SRC            0              0x0
  * 0x0011[6]     MS1_INT            0              0x0
  * 0x0011[7]     CLK1_PDN           0              0x0
  * 0x0012[1:0]   CLK2_IDRV          0              0x0
  * 0x0012[3:2]   CLK2_SRC           3              0x3
  * 0x0012[4]     CLK2_INV           0              0x0
  * 0x0012[5]     MS2_SRC            0              0x0
  * 0x0012[6]     MS2_INT            0              0x0
  * 0x0012[7]     CLK2_PDN           1              0x1
  * 0x0013[1:0]   CLK3_IDRV          0              0x0
  * 0x0013[3:2]   CLK3_SRC           3              0x3
  * 0x0013[4]     CLK3_INV           0              0x0
  * 0x0013[5]     MS3_SRC            0              0x0
  * 0x0013[6]     MS3_INT            0              0x0
  * 0x0013[7]     CLK3_PDN           1              0x1
  * 0x0014[1:0]   CLK4_IDRV          0              0x0
  * 0x0014[3:2]   CLK4_SRC           3              0x3
  * 0x0014[4]     CLK4_INV           0              0x0
  * 0x0014[5]     MS4_SRC            0              0x0
  * 0x0014[6]     MS4_INT            0              0x0
  * 0x0014[7]     CLK4_PDN           1              0x1
  * 0x0015[1:0]   CLK5_IDRV          0              0x0
  * 0x0015[3:2]   CLK5_SRC           3              0x3
  * 0x0015[4]     CLK5_INV           0              0x0
  * 0x0015[5]     MS5_SRC            0              0x0
  * 0x0015[6]     MS5_INT            0              0x0
  * 0x0015[7]     CLK5_PDN           1              0x1
  * 0x0016[1:0]   CLK6_IDRV          0              0x0
  * 0x0016[3:2]   CLK6_SRC           3              0x3
  * 0x0016[4]     CLK6_INV           0              0x0
  * 0x0016[5]     MS6_SRC            0              0x0
  * 0x0016[6]     FBA_INT            0              0x0
  * 0x0016[7]     CLK6_PDN           1              0x1
  * 0x0017[1:0]   CLK7_IDRV          0              0x0
  * 0x0017[3:2]   CLK7_SRC           3              0x3
  * 0x0017[4]     CLK7_INV           0              0x0
  * 0x0017[5]     MS7_SRC            0              0x0
  * 0x0017[6]     FBB_INT            0              0x0
  * 0x0017[7]     CLK7_PDN           1              0x1
  * 0x001C[17:0]  MSNA_P1            3753           0x00EA9
  * 0x001F[19:0]  MSNA_P2            613            0x00265
  * 0x001F[23:4]  MSNA_P3            675            0x002A3
  * 0x002C[17:0]  MS0_P1             111968         0x1B560
  * 0x002F[19:0]  MS0_P2             0              0x00000
  * 0x002F[23:4]  MS0_P4             4              0x00004
  * 0x0034[17:0]  MS1_P1             224448         0x36CC0
  * 0x0037[19:0]  MS1_P2             0              0x00000
  * 0x0037[23:4]  MS1_P4             2              0x00002
  * 0x005A[7:0]   MS6_P2             0              0x00
  * 0x005B[7:0]   MS7_P2             0              0x00
  * 0x0095[14:0]  SSDN_P2            0              0x0000
  * 0x0095[7]     SSC_EN             0              0x0
  * 0x0097[14:0]  SSDN_P3            0              0x0000
  * 0x0097[7]     SSC_MODE           0              0x0
  * 0x0099[11:0]  SSDN_P1            0              0x000
  * 0x009A[15:4]  SSUDP              0              0x000
  * 0x00A2[21:0]  VCXO_PARAM         0              0x000000
  * 0x00B7[2:0]   SLAB_PLLA_CL       2              0x2
  * 0x00B7[5:3]   SLAB_PLLB_CL       2              0x2
  * 0x00B7[7:6]   XTAL_CL            3              0x3
  *
  *
  */








uint64_t Si5351__pll_calc(uint64_t, struct Si5351RegSet *, int32_t, uint8_t);
uint64_t Si5351__multisynth_calc(uint64_t, uint64_t, struct Si5351RegSet *);
uint64_t Si5351__multisynth67_calc(uint64_t, uint64_t, struct Si5351RegSet *);
void Si5351__update_sys_status(struct Si5351Status *);
void Si5351__update_int_status(struct Si5351IntStatus *);
void Si5351__ms_div(enum si5351_clock, uint8_t, uint8_t);
uint8_t Si5351__select_r_div(uint64_t *);
uint8_t Si5351__select_r_div_ms67(uint64_t *);
int32_t Si5351__ref_correction;
uint8_t Si5351__i2c_bus_addr;

uint64_t Si5351__clk_freq[8];
uint64_t Si5351__plla_freq;
uint64_t Si5351__pllb_freq;
uint32_t Si5351__xtal_freq;
uint8_t Si5351_write_bulk(uint8_t, uint8_t, uint8_t *);
uint8_t Si5351_write(uint8_t, uint8_t);
uint8_t Si5351_read(uint8_t);
struct Si5351Status Si5351__dev_status;
struct Si5351IntStatus Si5351__dev_int_status;


uint8_t Si5351_write(uint8_t addr, uint8_t data)
{

	System_I2C_WriteRegister_8Bit(SI5351_I2C_ADDRESS,addr, data);

	return 0;

}


uint8_t Si5351_write_bulk(uint8_t addr, uint8_t bytes, uint8_t *data)
{
	uint8_t ret = 0;

	for(int i=0;i<bytes;i++)
	{

		System_I2C_WriteRegister_8Bit(SI5351_I2C_ADDRESS,addr, data[i]);

		addr++;
	}

	return ret;
}

uint8_t Si5351_read(uint8_t addr)
{
	uint8_t reg_val;

	System_I2C_ReadRegister_8Bit(SI5351_I2C_ADDRESS,addr, &reg_val);

	return reg_val;
}


uint32_t Si5361_DumpConfig()
{
	for(uint32_t i=0;i<SI5351A_REVB_REG_CONFIG_NUM_REGS;i++)
	{
			Si5351_write(
						(uint8_t)si5351a_revb_registers[i].address,
							(uint8_t)si5351a_revb_registers[i].value
					 	);
	}

	return 0;
}

/*
 * init(uint8_t xtal_load_c, uint32_t ref_osc_freq, int32_t corr)
 *
 * Setup communications to the Si5351 and set the crystal
 * load capacitance.
 *
 * xtal_load_c - Crystal load capacitance. Use the SI5351_CRYSTAL_LOAD_*PF
 * defines in the header file
 * ref_osc_freq - Crystal/reference oscillator frequency in 1 Hz increments.
 * Defaults to 25000000 if a 0 is used here.
 * corr - Frequency correction constant in parts-per-billion
 *
 */
void Si5351__init(uint8_t xtal_load_c, uint32_t ref_osc_freq, int32_t corr)
{

	Si5351__dev_status.SYS_INIT = 0;
	Si5351__dev_status.LOL_B = 0;
	Si5351__dev_status.LOL_A = 0;
	Si5351__dev_status.LOS = 0;
	Si5351__dev_status.REVID = 0;

	Si5351__dev_int_status.SYS_INIT_STKY = 0;
	Si5351__dev_int_status.LOL_B_STKY = 0;
	Si5351__dev_int_status.LOL_A_STKY = 0;
	Si5351__dev_int_status.LOS_STKY = 0;

	Si5351__xtal_freq = SI5351_XTAL_FREQ;

	// Set crystal load capacitance
	Si5351_write(SI5351_CRYSTAL_LOAD, (xtal_load_c & SI5351_CRYSTAL_LOAD_MASK) | 0b00010010);

	// Change the ref osc freq if different from default
	// Divide down if greater than 30 MHz
	if (ref_osc_freq != 0)
	{
		uint8_t reg_val;
		reg_val = Si5351_read(SI5351_PLL_INPUT_SOURCE);

		// Clear the bits first
		reg_val &= ~(SI5351_CLKIN_DIV_MASK);

		if(ref_osc_freq <= 30000000UL)
		{
			Si5351__xtal_freq = ref_osc_freq;
			reg_val |= SI5351_CLKIN_DIV_1;
		}
		else if(ref_osc_freq > 30000000UL && ref_osc_freq <= 60000000UL)
		{
			Si5351__xtal_freq = ref_osc_freq / 2;
			reg_val |= SI5351_CLKIN_DIV_2;
		}
		else if(ref_osc_freq > 60000000UL && ref_osc_freq <= 100000000UL)
		{
			Si5351__xtal_freq = ref_osc_freq / 4;
			reg_val |= SI5351_CLKIN_DIV_4;
		}

		Si5351_write(SI5351_PLL_INPUT_SOURCE, reg_val);
	}

	// Set the frequency calibration
	Si5351__set_correction(corr);

	Si5351__reset();
}




/*
 * reset(void)
 *
 * Call to reset the Si5351 to the state initialized by the library.
 *
 */
void Si5351__reset(void)
{
	// Initialize the CLK outputs according to flowchart in datasheet
	// First, turn them off
	Si5351_write(16, 0x80);
	Si5351_write(17, 0x80);
	Si5351_write(18, 0x80);
	Si5351_write(19, 0x80);
	Si5351_write(20, 0x80);
	Si5351_write(21, 0x80);
	Si5351_write(22, 0x80);
	Si5351_write(23, 0x80);


	// Turn the clocks back on...
	Si5351_write(16, 0x0c);
	Si5351_write(17, 0x0c);
	Si5351_write(18, 0x0c);
	Si5351_write(19, 0x0c);
	Si5351_write(20, 0x0c);
	Si5351_write(21, 0x0c);
	Si5351_write(22, 0x0c);
	Si5351_write(23, 0x0c);

	// Set PLLA to 800 MHz for automatic tuning
	Si5351__set_pll(SI5351_PLL_FIXED, SI5351_PLLA);
	Si5351__set_pll(SI5351_PLL_FIXED, SI5351_PLLB);

	// Make PLL to CLK assignments for automatic tuning
	Si5351__pll_assignment[0] = SI5351_PLLA;
	Si5351__pll_assignment[1] = SI5351_PLLA;
	Si5351__pll_assignment[2] = SI5351_PLLA;
	Si5351__pll_assignment[3] = SI5351_PLLA;
	Si5351__pll_assignment[4] = SI5351_PLLA;
	Si5351__pll_assignment[5] = SI5351_PLLA;
	Si5351__pll_assignment[6] = SI5351_PLLB;
	Si5351__pll_assignment[7] = SI5351_PLLB;

	Si5351__set_ms_source(SI5351_CLK0, SI5351_PLLA);
	Si5351__set_ms_source(SI5351_CLK1, SI5351_PLLA);
	Si5351__set_ms_source(SI5351_CLK2, SI5351_PLLA);
	Si5351__set_ms_source(SI5351_CLK3, SI5351_PLLA);
	Si5351__set_ms_source(SI5351_CLK4, SI5351_PLLA);
	Si5351__set_ms_source(SI5351_CLK5, SI5351_PLLA);
	Si5351__set_ms_source(SI5351_CLK6, SI5351_PLLB);
	Si5351__set_ms_source(SI5351_CLK7, SI5351_PLLB);

	// Reset the VCXO param
	Si5351_write(SI5351_VXCO_PARAMETERS_LOW, 0);
	Si5351_write(SI5351_VXCO_PARAMETERS_MID, 0);
	Si5351_write(SI5351_VXCO_PARAMETERS_HIGH, 0);

	// Then reset the PLLs
	Si5351__pll_reset(SI5351_PLLA);
	Si5351__pll_reset(SI5351_PLLB);

	// Set initial frequencies
	uint8_t i;
	for(i = 0; i < 8; i++)
	{
		Si5351__clk_freq[i] = 0;
		Si5351__output_enable((enum si5351_clock)i, 0);
	}
}

/*
 * set_freq(uint64_t freq, enum si5351_clock clk)
 *
 * Sets the clock frequency of the specified CLK output.
 * Frequency range of 8 kHz to 150 MHz
 *
 * freq - Output frequency in Hz
 * clk - Clock output
 *   (use the si5351_clock enum)
 */
uint8_t Si5351__set_freq(uint64_t freq, enum si5351_clock clk)
{
	struct Si5351RegSet ms_reg;
	uint64_t Si5351__pll_freq;
	uint8_t int_mode = 0;
	uint8_t div_by_4 = 0;
	uint8_t r_div = 0;

	// Check which Multisynth is being set
	if((uint8_t)clk <= (uint8_t)SI5351_CLK5)
	{
		// MS0 through MS5 logic
		// ---------------------

		// Lower bounds check
		if(freq > 0 && freq < SI5351_CLKOUT_MIN_FREQ * SI5351_FREQ_MULT)
		{
			freq = SI5351_CLKOUT_MIN_FREQ * SI5351_FREQ_MULT;
		}

		// Upper bounds check
		if(freq > SI5351_MULTISYNTH_MAX_FREQ * SI5351_FREQ_MULT)
		{
			freq = SI5351_MULTISYNTH_MAX_FREQ * SI5351_FREQ_MULT;
		}

		// If requested freq >100 MHz and no other outputs are already >100 MHz,
		// we need to recalculate PLLA and then recalculate all other CLK outputs
		// on same PLL
		if(freq > (SI5351_MULTISYNTH_SHARE_MAX * SI5351_FREQ_MULT))
		{
			// Check other clocks on same PLL
			uint8_t i;
			for(i = 0; i < 6; i++)
			{
				if(Si5351__clk_freq[i] > (SI5351_MULTISYNTH_SHARE_MAX * SI5351_FREQ_MULT))
				{
					if(i != (uint8_t)clk && Si5351__pll_assignment[i] == Si5351__pll_assignment[clk])
					{
						return 1; // won't set if any other clks already >100 MHz
					}
				}
			}

			// Enable the output
			Si5351__output_enable(clk, 1);

			// Set the freq in memory
			Si5351__clk_freq[(uint8_t)clk] = freq;

			// Calculate the proper PLL frequency
			Si5351__pll_freq = Si5351__multisynth_calc(freq, 0, &ms_reg);

			// Set PLL
			Si5351__set_pll(Si5351__pll_freq, Si5351__pll_assignment[clk]);

			// Recalculate params for other synths on same PLL
			for(i = 0; i < 6; i++)
			{
				if(Si5351__clk_freq[i] != 0)
				{
					if(Si5351__pll_assignment[i] == Si5351__pll_assignment[clk])
					{
						struct Si5351RegSet temp_reg;
						uint64_t temp_freq;

						// Select the proper R div value
						temp_freq = Si5351__clk_freq[i];
						r_div = Si5351__select_r_div(&temp_freq);

						Si5351__multisynth_calc(temp_freq, Si5351__pll_freq, &temp_reg);

						// If freq > 150 MHz, we need to use DIVBY4 and integer mode
						if(temp_freq >= SI5351_MULTISYNTH_DIVBY4_FREQ * SI5351_FREQ_MULT)
						{
							div_by_4 = 1;
							int_mode = 1;
						}
						else
						{
							div_by_4 = 0;
							int_mode = 0;
						}

						// Set multisynth registers
						Si5351__set_ms((enum si5351_clock)i, temp_reg, int_mode, r_div, div_by_4);
					}
				}
			}

			// Reset the PLL
			Si5351__pll_reset(Si5351__pll_assignment[clk]);
		}
		else
		{
			Si5351__clk_freq[(uint8_t)clk] = freq;

			// Enable the output
			Si5351__output_enable(clk, 1);

			// Select the proper R div value
			r_div = Si5351__select_r_div(&freq);

			// Calculate the synth parameters
			if(Si5351__pll_assignment[clk] == SI5351_PLLA)
			{
				Si5351__multisynth_calc(freq, Si5351__plla_freq, &ms_reg);
			}
			else
			{
				Si5351__multisynth_calc(freq, Si5351__pllb_freq, &ms_reg);
			}

			// Set multisynth registers
			Si5351__set_ms(clk, ms_reg, int_mode, r_div, div_by_4);

			// Reset the PLL
			Si5351__pll_reset(Si5351__pll_assignment[clk]);
		}

		return 0;
	}
	else
	{
		// MS6 and MS7 logic
		// -----------------

		// Lower bounds check
		if(freq > 0 && freq < SI5351_CLKOUT67_MIN_FREQ * SI5351_FREQ_MULT)
		{
			freq = SI5351_CLKOUT_MIN_FREQ * SI5351_FREQ_MULT;
		}

		// Upper bounds check
		if(freq >= SI5351_MULTISYNTH_DIVBY4_FREQ * SI5351_FREQ_MULT)
		{
			freq = SI5351_MULTISYNTH_DIVBY4_FREQ * SI5351_FREQ_MULT - 1;
		}

		// If one of CLK6 or CLK7 is already set when trying to set the other,
		// we have to ensure that it will also have an integer division ratio
		// with the same PLL, otherwise do not set it.
		if(clk == SI5351_CLK6)
		{
			if(Si5351__clk_freq[7] != 0)
			{
				if(Si5351__pllb_freq % freq == 0)
				{
					if((Si5351__pllb_freq / freq) % 2 != 0)
					{
						// Not an even divide ratio, no bueno
						return 1;
					}
					else
					{
						// Set the freq in memory
						Si5351__clk_freq[(uint8_t)clk] = freq;

						// Select the proper R div value
						r_div = Si5351__select_r_div_ms67(&freq);

						Si5351__multisynth67_calc(freq, Si5351__pllb_freq, &ms_reg);
					}
				}
				else
				{
					// Not an integer divide ratio, no good
					return 1;
				}
			}
			else
			{
				// No previous assignment, so set PLLB based on CLK6

				// Set the freq in memory
				Si5351__clk_freq[(uint8_t)clk] = freq;

				// Select the proper R div value
				r_div = Si5351__select_r_div_ms67(&freq);

				Si5351__pll_freq = Si5351__multisynth67_calc(freq, 0, &ms_reg);
				//Si5351__pllb_freq = Si5351__pll_freq;
				Si5351__set_pll(Si5351__pll_freq, SI5351_PLLB);
			}
		}
		else
		{
			if(Si5351__clk_freq[6] != 0)
			{
				if(Si5351__pllb_freq % freq == 0)
				{
					if((Si5351__pllb_freq / freq) % 2 != 0)
					{
						// Not an even divide ratio, no bueno
						return 1;
					}
					else
					{
						// Set the freq in memory
						Si5351__clk_freq[(uint8_t)clk] = freq;

						// Select the proper R div value
						r_div = Si5351__select_r_div_ms67(&freq);

						Si5351__multisynth67_calc(freq, Si5351__pllb_freq, &ms_reg);
					}
				}
				else
				{
					// Not an integer divide ratio, no good
					return 1;
				}
			}
			else
			{
				// No previous assignment, so set PLLB based on CLK7

				// Set the freq in memory
				Si5351__clk_freq[(uint8_t)clk] = freq;

				// Select the proper R div value
				r_div = Si5351__select_r_div_ms67(&freq);

				Si5351__pll_freq = Si5351__multisynth67_calc(freq, 0, &ms_reg);
				//Si5351__pllb_freq = Si5351__pll_freq;
				Si5351__set_pll(Si5351__pll_freq, Si5351__pll_assignment[clk]);
			}
		}

		// Enable the output
		Si5351__output_enable(clk, 1);

		div_by_4 = 0;
		int_mode = 0;

		// Set multisynth registers (MS must be set before PLL)
		Si5351__set_ms(clk, ms_reg, int_mode, r_div, div_by_4);

		return 0;
	}
}

/*
 * set_freq_manual(uint64_t freq, uint64_t Si5351__pll_freq, enum si5351_clock clk)
 *
 * Sets the clock frequency of the specified CLK output using the given PLL
 * frequency. You must ensure that the MS is assigned to the correct PLL and
 * that the PLL is set to the correct frequency before using this method.
 *
 * It is important to note that if you use this method, you will have to
 * track that all settings are sane yourself.
 *
 * freq - Output frequency in Hz
 * Si5351__pll_freq - Frequency of the PLL driving the Multisynth
 * clk - Clock output
 *   (use the si5351_clock enum)
 */
uint8_t Si5351__set_freq_manual(uint64_t freq, uint64_t Si5351__pll_freq, enum si5351_clock clk)
{
	struct Si5351RegSet ms_reg;
	uint8_t int_mode = 0;
	uint8_t div_by_4 = 0;

	// Lower bounds check
	if(freq > 0 && freq < SI5351_CLKOUT_MIN_FREQ * SI5351_FREQ_MULT)
	{
		freq = SI5351_CLKOUT_MIN_FREQ * SI5351_FREQ_MULT;
	}

	// Upper bounds check
	if(freq > SI5351_CLKOUT_MAX_FREQ * SI5351_FREQ_MULT)
	{
		freq = SI5351_CLKOUT_MAX_FREQ * SI5351_FREQ_MULT;
	}

	uint8_t r_div;

	Si5351__clk_freq[(uint8_t)clk] = freq;

	Si5351__set_pll(Si5351__pll_freq, Si5351__pll_assignment[clk]);

	// Enable the output
	Si5351__output_enable(clk, 1);

	// Select the proper R div value
	r_div = Si5351__select_r_div(&freq);

	// Calculate the synth parameters
	Si5351__multisynth_calc(freq, Si5351__pll_freq, &ms_reg);

	// If freq > 150 MHz, we need to use DIVBY4 and integer mode
	if(freq >= SI5351_MULTISYNTH_DIVBY4_FREQ * SI5351_FREQ_MULT)
	{
		div_by_4 = 1;
		int_mode = 1;
	}

	// Set multisynth registers (MS must be set before PLL)
	Si5351__set_ms(clk, ms_reg, int_mode, r_div, div_by_4);

	return 0;
}

/*
 * Si5351__set_pll(uint64_t Si5351__pll_freq, enum si5351_pll target_pll)
 *
 * Set the specified PLL to a specific oscillation frequency
 *
 * Si5351__pll_freq - Desired PLL frequency
 * target_pll - Which PLL to set
 *     (use the si5351_pll enum)
 */
void Si5351__set_pll(uint64_t Si5351__pll_freq, enum si5351_pll target_pll)
{
  struct Si5351RegSet pll_reg;

  Si5351__pll_calc(Si5351__pll_freq, &pll_reg, Si5351__ref_correction, 0);

  // Derive the register values to write

  // Prepare an array for parameters to be written to
  uint8_t params[20];
  uint8_t i = 0;
  uint8_t temp;

  // Registers 26-27
  temp = ((pll_reg.p3 >> 8) & 0xFF);
  params[i++] = temp;

  temp = (uint8_t)(pll_reg.p3  & 0xFF);
  params[i++] = temp;

  // Register 28
  temp = (uint8_t)((pll_reg.p1 >> 16) & 0x03);
  params[i++] = temp;

  // Registers 29-30
  temp = (uint8_t)((pll_reg.p1 >> 8) & 0xFF);
  params[i++] = temp;

  temp = (uint8_t)(pll_reg.p1  & 0xFF);
  params[i++] = temp;

  // Register 31
  temp = (uint8_t)((pll_reg.p3 >> 12) & 0xF0);
  temp += (uint8_t)((pll_reg.p2 >> 16) & 0x0F);
  params[i++] = temp;

  // Registers 32-33
  temp = (uint8_t)((pll_reg.p2 >> 8) & 0xFF);
  params[i++] = temp;

  temp = (uint8_t)(pll_reg.p2  & 0xFF);
  params[i++] = temp;

  // Write the parameters
  if(target_pll == SI5351_PLLA)
  {
    Si5351_write_bulk(SI5351_PLLA_PARAMETERS, i, params);
		Si5351__plla_freq = Si5351__pll_freq;
  }
  else if(target_pll == SI5351_PLLB)
  {
    Si5351_write_bulk(SI5351_PLLB_PARAMETERS, i, params);
		Si5351__pllb_freq = Si5351__pll_freq;
  }


}

/*
 * set_ms(enum si5351_clock clk, struct Si5351RegSet ms_reg, uint8_t int_mode, uint8_t r_div, uint8_t div_by_4)
 *
 * Set the specified multisynth parameters. Not normally needed, but public for advanced users.
 *
 * clk - Clock output
 *   (use the si5351_clock enum)
 * int_mode - Set integer mode
 *  Set to 1 to enable, 0 to disable
 * r_div - Desired r_div ratio
 * div_by_4 - Set Divide By 4 mode
 *   Set to 1 to enable, 0 to disable
 */
void Si5351__set_ms(enum si5351_clock clk, struct Si5351RegSet ms_reg, uint8_t int_mode, uint8_t r_div, uint8_t div_by_4)
{
	uint8_t params[20];
	uint8_t i = 0;
 	uint8_t temp;
 	uint8_t reg_val;


	if((uint8_t)clk <= (uint8_t)SI5351_CLK5)
	{
		// Registers 42-43 for CLK0
		temp = (uint8_t)((ms_reg.p3 >> 8) & 0xFF);
		params[i++] = temp;

		temp = (uint8_t)(ms_reg.p3  & 0xFF);
		params[i++] = temp;

		// Register 44 for CLK0
		reg_val = Si5351_read((SI5351_CLK0_PARAMETERS + 2) + (clk * 8));
		reg_val &= ~(0x03);
		temp = reg_val | ((uint8_t)((ms_reg.p1 >> 16) & 0x03));
		params[i++] = temp;

		// Registers 45-46 for CLK0
		temp = (uint8_t)((ms_reg.p1 >> 8) & 0xFF);
		params[i++] = temp;

		temp = (uint8_t)(ms_reg.p1  & 0xFF);
		params[i++] = temp;

		// Register 47 for CLK0
		temp = (uint8_t)((ms_reg.p3 >> 12) & 0xF0);
		temp += (uint8_t)((ms_reg.p2 >> 16) & 0x0F);
		params[i++] = temp;

		// Registers 48-49 for CLK0
		temp = (uint8_t)((ms_reg.p2 >> 8) & 0xFF);
		params[i++] = temp;

		temp = (uint8_t)(ms_reg.p2  & 0xFF);
		params[i++] = temp;
	}
	else
	{
		// MS6 and MS7 only use one register
		temp = ms_reg.p1;
	}

	// Write the parameters
	switch(clk)
	{
		case SI5351_CLK0:
			Si5351_write_bulk(SI5351_CLK0_PARAMETERS, i, params);
			Si5351__set_int(clk, int_mode);
			Si5351__ms_div(clk, r_div, div_by_4);
			break;
		case SI5351_CLK1:
			Si5351_write_bulk(SI5351_CLK1_PARAMETERS, i, params);
			Si5351__set_int(clk, int_mode);
			Si5351__ms_div(clk, r_div, div_by_4);
			break;
		case SI5351_CLK2:
			Si5351_write_bulk(SI5351_CLK2_PARAMETERS, i, params);
			Si5351__set_int(clk, int_mode);
			Si5351__ms_div(clk, r_div, div_by_4);
			break;
		case SI5351_CLK3:
			Si5351_write_bulk(SI5351_CLK3_PARAMETERS, i, params);
			Si5351__set_int(clk, int_mode);
			Si5351__ms_div(clk, r_div, div_by_4);
			break;
		case SI5351_CLK4:
			Si5351_write_bulk(SI5351_CLK4_PARAMETERS, i, params);
			Si5351__set_int(clk, int_mode);
			Si5351__ms_div(clk, r_div, div_by_4);
			break;
		case SI5351_CLK5:
			Si5351_write_bulk(SI5351_CLK5_PARAMETERS, i, params);
			Si5351__set_int(clk, int_mode);
			Si5351__ms_div(clk, r_div, div_by_4);
			break;
		case SI5351_CLK6:
			Si5351_write(SI5351_CLK6_PARAMETERS, temp);
			Si5351__ms_div(clk, r_div, div_by_4);
			break;
		case SI5351_CLK7:
			Si5351_write(SI5351_CLK7_PARAMETERS, temp);
			Si5351__ms_div(clk, r_div, div_by_4);
			break;
	}

}

/*
 * output_enable(enum si5351_clock clk, uint8_t enable)
 *
 * Enable or disable a chosen output
 * clk - Clock output
 *   (use the si5351_clock enum)
 * enable - Set to 1 to enable, 0 to disable
 */
void Si5351__output_enable(enum si5351_clock clk, uint8_t enable)
{
  uint8_t reg_val;

  reg_val = Si5351_read(SI5351_OUTPUT_ENABLE_CTRL);

  if(enable == 1)
  {
    reg_val &= ~(1<<(uint8_t)clk);
  }
  else
  {
    reg_val |= (1<<(uint8_t)clk);
  }

  Si5351_write(SI5351_OUTPUT_ENABLE_CTRL, reg_val);
}

/*
 * drive_strength(enum si5351_clock clk, enum si5351_drive drive)
 *
 * Sets the drive strength of the specified clock output
 *
 * clk - Clock output
 *   (use the si5351_clock enum)
 * drive - Desired drive level
 *   (use the si5351_drive enum)
 */
void Si5351__drive_strength(enum si5351_clock clk, enum si5351_drive drive)
{
  uint8_t reg_val;
  const uint8_t mask = 0x03;

  reg_val = Si5351_read(SI5351_CLK0_CTRL + (uint8_t)clk);
  reg_val &= ~(mask);

  switch(drive)
  {
  case SI5351_DRIVE_2MA:
    reg_val |= 0x00;
    break;
  case SI5351_DRIVE_4MA:
   reg_val |= 0x01;
    break;
  case SI5351_DRIVE_6MA:
    reg_val |= 0x02;
    break;
  case SI5351_DRIVE_8MA:
    reg_val |= 0x03;
    break;
  default:
    break;
  }

  Si5351_write(SI5351_CLK0_CTRL + (uint8_t)clk, reg_val);
}

/*
 * update_status(void)
 *
 * Call this to update the status structs, then access them
 * via the Si5351__dev_status and Si5351__dev_int_status global members.
 *
 * See the header file for the struct definitions. These
 * correspond to the flag names for registers 0 and 1 in
 * the Si5351 datasheet.
 */
void Si5351__update_status(void)
{
	Si5351__update_sys_status(&Si5351__dev_status);
	Si5351__update_int_status(&Si5351__dev_int_status);
}

/*
 * set_correction(int32_t corr)
 *
 * Use this to set the oscillator correction factor.
 * This value is a signed 32-bit integer of the
 * parts-per-billion value that the actual oscillation
 * frequency deviates from the specified frequency.
 *
 * The frequency calibration is done as a one-time procedure.
 * Any desired test frequency within the normal range of the
 * Si5351 should be set, then the actual output frequency
 * should be measured as accurately as possible. The
 * difference between the measured and specified frequencies
 * should be calculated in Hertz, then multiplied by 10 in
 * order to get the parts-per-billion value.
 *
 * Since the Si5351 itself has an intrinsic 0 PPM error, this
 * correction factor is good across the entire tuning range of
 * the Si5351. Once this calibration is done accurately, it
 * should not have to be done again for the same Si5351 and
 * crystal.
 */
void Si5351__set_correction(int32_t corr)
{
	Si5351__ref_correction = corr;
}

/*
 * set_phase(enum si5351_clock clk, uint8_t phase)
 *
 * clk - Clock output
 *   (use the si5351_clock enum)
 * phase - 7-bit phase word
 *   (in units of VCO/4 period)
 *
 * Write the 7-bit phase register. This must be used
 * with a user-set PLL frequency so that the user can
 * calculate the proper tuning word based on the PLL period.
 */
void Si5351__set_phase(enum si5351_clock clk, uint8_t phase)
{
	// Mask off the upper bit since it is reserved
	phase = phase & 0b01111111;

	Si5351_write(SI5351_CLK0_PHASE_OFFSET + (uint8_t)clk, phase);
}

/*
 * get_correction(void)
 *
 * Returns the oscillator correction factor stored
 * in RAM.
 */
int32_t Si5351__get_correction(void)
{
	return Si5351__ref_correction;
}

/*
 * pll_reset(enum si5351_pll target_pll)
 *
 * target_pll - Which PLL to reset
 *     (use the si5351_pll enum)
 *
 * Apply a reset to the indicated PLL.
 */
void Si5351__pll_reset(enum si5351_pll target_pll)
{
	if(target_pll == SI5351_PLLA)
 	{
    	Si5351_write(SI5351_PLL_RESET, SI5351_PLL_RESET_A);
	}
	else if(target_pll == SI5351_PLLB)
	{
	    Si5351_write(SI5351_PLL_RESET, SI5351_PLL_RESET_B);
	}
}

/*
 * set_ms_source(enum si5351_clock clk, enum si5351_pll pll)
 *
 * clk - Clock output
 *   (use the si5351_clock enum)
 * pll - Which PLL to use as the source
 *     (use the si5351_pll enum)
 *
 * Set the desired PLL source for a multisynth.
 */
void Si5351__set_ms_source(enum si5351_clock clk, enum si5351_pll pll)
{
	uint8_t reg_val;

	reg_val = Si5351_read(SI5351_CLK0_CTRL + (uint8_t)clk);

	if(pll == SI5351_PLLA)
	{
		reg_val &= ~(SI5351_CLK_PLL_SELECT);
	}
	else if(pll == SI5351_PLLB)
	{
		reg_val |= SI5351_CLK_PLL_SELECT;
	}

	Si5351_write(SI5351_CLK0_CTRL + (uint8_t)clk, reg_val);

	Si5351__pll_assignment[(uint8_t)clk] = pll;
}

/*
 * set_int(enum si5351_clock clk, uint8_t int_mode)
 *
 * clk - Clock output
 *   (use the si5351_clock enum)
 * enable - Set to 1 to enable, 0 to disable
 *
 * Set the indicated multisynth into integer mode.
 */
void Si5351__set_int(enum si5351_clock clk, uint8_t enable)
{
	uint8_t reg_val;
	reg_val = Si5351_read(SI5351_CLK0_CTRL + (uint8_t)clk);

	if(enable == 1)
	{
		reg_val |= (SI5351_CLK_INTEGER_MODE);
	}
	else
	{
		reg_val &= ~(SI5351_CLK_INTEGER_MODE);
	}

	Si5351_write(SI5351_CLK0_CTRL + (uint8_t)clk, reg_val);

	// Integer mode indication
	/*
	switch(clk)
	{
	case SI5351_CLK0:
		clk0_int_mode = enable;
		break;
	case SI5351_CLK1:
		clk1_int_mode = enable;
		break;
	case SI5351_CLK2:
		clk2_int_mode = enable;
		break;
	default:
		break;
	}
	*/
}

/*
 * set_clock_pwr(enum si5351_clock clk, uint8_t pwr)
 *
 * clk - Clock output
 *   (use the si5351_clock enum)
 * pwr - Set to 1 to enable, 0 to disable
 *
 * Enable or disable power to a clock output (a power
 * saving feature).
 */
void Si5351__set_clock_pwr(enum si5351_clock clk, uint8_t pwr)
{
	uint8_t reg_val;
	reg_val = Si5351_read(SI5351_CLK0_CTRL + (uint8_t)clk);

	if(pwr == 1)
	{
		reg_val &= 0b01111111;
	}
	else
	{
		reg_val |= 0b10000000;
	}

	Si5351_write(SI5351_CLK0_CTRL + (uint8_t)clk, reg_val);
}

/*
 * set_clock_invert(enum si5351_clock clk, uint8_t inv)
 *
 * clk - Clock output
 *   (use the si5351_clock enum)
 * inv - Set to 1 to enable, 0 to disable
 *
 * Enable to invert the clock output waveform.
 */
void Si5351__set_clock_invert(enum si5351_clock clk, uint8_t inv)
{
	uint8_t reg_val;
	reg_val = Si5351_read(SI5351_CLK0_CTRL + (uint8_t)clk);

	if(inv == 1)
	{
		reg_val |= (SI5351_CLK_INVERT);
	}
	else
	{
		reg_val &= ~(SI5351_CLK_INVERT);
	}

	Si5351_write(SI5351_CLK0_CTRL + (uint8_t)clk, reg_val);
}

/*
 * set_clock_source(enum si5351_clock clk, enum si5351_clock_source src)
 *
 * clk - Clock output
 *   (use the si5351_clock enum)
 * src - Which clock source to use for the multisynth
 *   (use the si5351_clock_source enum)
 *
 * Set the clock source for a multisynth (based on the options
 * presented for Registers 16-23 in the Silicon Labs AN619 document).
 * Choices are XTAL, CLKIN, MS0, or the multisynth associated with
 * the clock output.
 */
void Si5351__set_clock_source(enum si5351_clock clk, enum si5351_clock_source src)
{
	uint8_t reg_val;
	reg_val = Si5351_read(SI5351_CLK0_CTRL + (uint8_t)clk);

	// Clear the bits first
	reg_val &= ~(SI5351_CLK_INPUT_MASK);

	switch(src)
	{
	case SI5351_CLK_SRC_XTAL:
		reg_val |= (SI5351_CLK_INPUT_XTAL);
		break;
	case SI5351_CLK_SRC_CLKIN:
		reg_val |= (SI5351_CLK_INPUT_CLKIN);
		break;
	case SI5351_CLK_SRC_MS0:
		if(clk == SI5351_CLK0)
		{
			return;
		}

		reg_val |= (SI5351_CLK_INPUT_MULTISYNTH_0_4);
		break;
	case SI5351_CLK_SRC_MS:
		reg_val |= (SI5351_CLK_INPUT_MULTISYNTH_N);
		break;
	default:
		return;
	}

	Si5351_write(SI5351_CLK0_CTRL + (uint8_t)clk, reg_val);
}

/*
 * set_clock_disable(enum si5351_clock clk, enum si5351_clock_disable dis_state)
 *
 * clk - Clock output
 *   (use the si5351_clock enum)
 * dis_state - Desired state of the output upon disable
 *   (use the si5351_clock_disable enum)
 *
 * Set the state of the clock output when it is disabled. Per page 27
 * of AN619 (Registers 24 and 25), there are four possible values: low,
 * high, high impedance, and never disabled.
 */
void Si5351__set_clock_disable(enum si5351_clock clk, enum si5351_clock_disable dis_state)
{
	uint8_t reg_val=0;
	uint8_t reg =0;

	if (clk >= SI5351_CLK0 && clk <= SI5351_CLK3)
	{
		reg = SI5351_CLK3_0_DISABLE_STATE;
	}
	else if(clk >= SI5351_CLK4 && clk <= SI5351_CLK7)
	{
		reg = SI5351_CLK7_4_DISABLE_STATE;
	}

	reg_val = Si5351_read(reg);

	if (clk >= SI5351_CLK0 && clk <= SI5351_CLK3)
	{
		reg_val &= ~(0b11 << (clk * 2));
		reg_val |= dis_state << (clk * 2);
	}
	else if(clk >= SI5351_CLK4 && clk <= SI5351_CLK7)
	{
		reg_val &= ~(0b11 << ((clk - 4) * 2));
		reg_val |= dis_state << ((clk - 4) * 2);
	}

	Si5351_write(reg, reg_val);
}

/*
 * set_clock_fanout(enum si5351_clock_fanout fanout, uint8_t enable)
 *
 * fanout - Desired clock fanout
 *   (use the si5351_clock_fanout enum)
 * enable - Set to 1 to enable, 0 to disable
 *
 * Use this function to enable or disable the clock fanout options
 * for individual clock outputs. If you intend to output the XO or
 * CLKIN on the clock outputs, enable this first.
 *
 * By default, only the Multisynth fanout is enabled at startup.
 */
void Si5351__set_clock_fanout(enum si5351_clock_fanout fanout, uint8_t enable)
{
	uint8_t reg_val;
	reg_val = Si5351_read(SI5351_FANOUT_ENABLE);

	switch(fanout)
	{
	case SI5351_FANOUT_CLKIN:
		if(enable)
		{
			reg_val |= SI5351_CLKIN_ENABLE;
		}
		else
		{
			reg_val &= ~(SI5351_CLKIN_ENABLE);
		}
		break;
	case SI5351_FANOUT_XO:
		if(enable)
		{
			reg_val |= SI5351_XTAL_ENABLE;
		}
		else
		{
			reg_val &= ~(SI5351_XTAL_ENABLE);
		}
		break;
	case SI5351_FANOUT_MS:
		if(enable)
		{
			reg_val |= SI5351_MULTISYNTH_ENABLE;
		}
		else
		{
			reg_val &= ~(SI5351_MULTISYNTH_ENABLE);
		}
		break;
	}

	Si5351_write(SI5351_FANOUT_ENABLE, reg_val);
}

/*
 * set_pll_input(enum si5351_pll pll, enum si5351_pll_input input)
 *
 * pll - Which PLL to use as the source
 *     (use the si5351_pll enum)
 * input - Which reference oscillator to use as PLL input
 *     (use the si5351_pll_input enum)
 *
 * Set the desired reference oscillator source for the given PLL.
 */
void Si5351__set_pll_input(enum si5351_pll pll, enum si5351_pll_input input)
{
	uint8_t reg_val;
	reg_val = Si5351_read(SI5351_PLL_INPUT_SOURCE);

	switch(pll)
	{
	case SI5351_PLLA:
		if(input == SI5351_PLL_INPUT_CLKIN)
		{
			reg_val |= SI5351_PLLA_SOURCE;
		}
		else
		{
			reg_val &= ~(SI5351_PLLA_SOURCE);
		}
		break;
	case SI5351_PLLB:
		if(input == SI5351_PLL_INPUT_CLKIN)
		{
			reg_val |= SI5351_PLLB_SOURCE;
		}
		else
		{
			reg_val &= ~(SI5351_PLLB_SOURCE);
		}
		break;
	default:
		return;
	}

	Si5351_write(SI5351_PLL_INPUT_SOURCE, reg_val);
}

void Si5351__set_vcxo(uint64_t Si5351__pll_freq, uint8_t ppm)
{
	struct Si5351RegSet pll_reg;
	uint64_t vcxo_param;

	// Bounds check
	if(ppm < SI5351_VCXO_PULL_MIN)
	{
		ppm = SI5351_VCXO_PULL_MIN;
	}

	if(ppm > SI5351_VCXO_PULL_MAX)
	{
		ppm = SI5351_VCXO_PULL_MAX;
	}

	// Set PLLB params
	vcxo_param = Si5351__pll_calc(Si5351__pll_freq, &pll_reg, Si5351__ref_correction, 1);

	// Derive the register values to write

	// Prepare an array for parameters to be written to
	uint8_t params[20];
	uint8_t i = 0;
	uint8_t temp;

	// Registers 26-27
	temp = ((pll_reg.p3 >> 8) & 0xFF);
	params[i++] = temp;

	temp = (uint8_t)(pll_reg.p3  & 0xFF);
	params[i++] = temp;

	// Register 28
	temp = (uint8_t)((pll_reg.p1 >> 16) & 0x03);
	params[i++] = temp;

	// Registers 29-30
	temp = (uint8_t)((pll_reg.p1 >> 8) & 0xFF);
	params[i++] = temp;

	temp = (uint8_t)(pll_reg.p1  & 0xFF);
	params[i++] = temp;

	// Register 31
	temp = (uint8_t)((pll_reg.p3 >> 12) & 0xF0);
	temp += (uint8_t)((pll_reg.p2 >> 16) & 0x0F);
	params[i++] = temp;

	// Registers 32-33
	temp = (uint8_t)((pll_reg.p2 >> 8) & 0xFF);
	params[i++] = temp;

	temp = (uint8_t)(pll_reg.p2  & 0xFF);
	params[i++] = temp;

	// Write the parameters
	Si5351_write_bulk(SI5351_PLLB_PARAMETERS, i, params);

	// Write the VCXO parameters
	vcxo_param = (vcxo_param * ppm) / RFRAC_DENOM;

	temp = (uint8_t)(vcxo_param & 0xFF);
	Si5351_write(SI5351_VXCO_PARAMETERS_LOW, temp);

	temp = (uint8_t)((vcxo_param >> 8) & 0xFF);
	Si5351_write(SI5351_VXCO_PARAMETERS_MID, temp);

	temp = (uint8_t)((vcxo_param >> 16) & 0x3F);
	Si5351_write(SI5351_VXCO_PARAMETERS_HIGH, temp);
}

/*********************/
/* Private functions */
/*********************/

uint64_t Si5351__pll_calc(uint64_t freq, struct Si5351RegSet *reg, int32_t correction, uint8_t vcxo)
{
	uint64_t ref_freq = Si5351__xtal_freq * SI5351_FREQ_MULT;
	uint32_t a, b, c, p1, p2, p3;
	uint64_t lltmp;

	// Factor calibration value into nominal crystal frequency
	// Measured in parts-per-billion

	ref_freq = ref_freq + (int32_t)((((((int64_t)correction) << 31) / 1000000000LL) * ref_freq) >> 31);

	// PLL bounds checking
	if (freq < SI5351_PLL_VCO_MIN * SI5351_FREQ_MULT)
	{
		freq = SI5351_PLL_VCO_MIN * SI5351_FREQ_MULT;
	}
	if (freq > SI5351_PLL_VCO_MAX * SI5351_FREQ_MULT)
	{
		freq = SI5351_PLL_VCO_MAX * SI5351_FREQ_MULT;
	}

	// Determine integer part of feedback equation
	a = freq / ref_freq;

	if (a < SI5351_PLL_A_MIN)
	{
		freq = ref_freq * SI5351_PLL_A_MIN;
	}
	if (a > SI5351_PLL_A_MAX)
	{
		freq = ref_freq * SI5351_PLL_A_MAX;
	}

	// Find best approximation for b/c = fVCO mod fIN
	// denom = 1000ULL * 1000ULL;
	// lltmp = freq % ref_freq;
	// lltmp *= denom;
	// do_div(lltmp, ref_freq);

	//b = (((uint64_t)(freq % ref_freq)) * RFRAC_DENOM) / ref_freq;
	if(vcxo)
	{
		b = (((uint64_t)(freq % ref_freq)) * 1000000ULL) / ref_freq;
		c = 1000000ULL;
	}
	else
	{
		b = (((uint64_t)(freq % ref_freq)) * RFRAC_DENOM) / ref_freq;
		c = b ? RFRAC_DENOM : 1;
	}

	// Calculate parameters
  p1 = 128 * a + ((128 * b) / c) - 512;
  p2 = 128 * b - c * ((128 * b) / c);
  p3 = c;

	// Recalculate frequency as fIN * (a + b/c)
	lltmp = ref_freq;
	lltmp *= b;
	do_div(lltmp, c);
	freq = lltmp;
	freq += ref_freq * a;

	reg->p1 = p1;
	reg->p2 = p2;
	reg->p3 = p3;

	if(vcxo)
	{
		return (uint64_t)(128 * a * SI5351_VCXO_MARGIN + b * SI5351_VCXO_MARGIN);
	}
	else
	{
		return freq;
	}
}

uint64_t Si5351__multisynth_calc(uint64_t freq, uint64_t Si5351__pll_freq, struct Si5351RegSet *reg)
{
	uint64_t lltmp;
	uint32_t a, b, c, p1, p2, p3;
	uint8_t divby4 = 0;
	uint8_t ret_val = 0;

	// Multisynth bounds checking
	if (freq > SI5351_MULTISYNTH_MAX_FREQ * SI5351_FREQ_MULT)
	{
		freq = SI5351_MULTISYNTH_MAX_FREQ * SI5351_FREQ_MULT;
	}
	if (freq < SI5351_MULTISYNTH_MIN_FREQ * SI5351_FREQ_MULT)
	{
		freq = SI5351_MULTISYNTH_MIN_FREQ * SI5351_FREQ_MULT;
	}

	if (freq >= SI5351_MULTISYNTH_DIVBY4_FREQ * SI5351_FREQ_MULT)
	{
		divby4 = 1;
	}

	if(Si5351__pll_freq == 0)
	{
		// Find largest integer divider for max
		// VCO frequency and given target frequency
		if(divby4 == 0)
		{
			lltmp = SI5351_PLL_VCO_MAX * SI5351_FREQ_MULT; // margin needed?
			do_div(lltmp, freq);
			if(lltmp == 5)
			{
				lltmp = 4;
			}
			else if(lltmp == 7)
			{
				lltmp = 6;
			}
			a = (uint32_t)lltmp;
		}
		else
		{
			a = 4;
		}

		b = 0;
		c = 1;
		Si5351__pll_freq = a * freq;
	}
	else
	{
		// Preset PLL, so return the actual freq for these params instead of PLL freq
		ret_val = 1;

		// Determine integer part of feedback equation
		a = Si5351__pll_freq / freq;

		if (a < SI5351_MULTISYNTH_A_MIN)
		{
			freq = Si5351__pll_freq / SI5351_MULTISYNTH_A_MIN;
		}
		if (a > SI5351_MULTISYNTH_A_MAX)
		{
			freq = Si5351__pll_freq / SI5351_MULTISYNTH_A_MAX;
		}

		b = (Si5351__pll_freq % freq * RFRAC_DENOM) / freq;
		c = b ? RFRAC_DENOM : 1;
	}

	// Calculate parameters
	if (divby4 == 1)
	{
		p3 = 1;
		p2 = 0;
		p1 = 0;
	}
	else
	{
    p1 = 128 * a + ((128 * b) / c) - 512;
    p2 = 128 * b - c * ((128 * b) / c);
    p3 = c;
	}

	reg->p1 = p1;
	reg->p2 = p2;
	reg->p3 = p3;

	if(ret_val == 0)
	{
		return Si5351__pll_freq;
	}
	else
	{
		return freq;
	}
}

uint64_t Si5351__multisynth67_calc(uint64_t freq, uint64_t Si5351__pll_freq, struct Si5351RegSet *reg)
{

	uint32_t a;
	uint64_t lltmp;

	// Multisynth bounds checking
	if(freq > SI5351_MULTISYNTH67_MAX_FREQ * SI5351_FREQ_MULT)
	{
		freq = SI5351_MULTISYNTH67_MAX_FREQ * SI5351_FREQ_MULT;
	}
	if(freq < SI5351_MULTISYNTH_MIN_FREQ * SI5351_FREQ_MULT)
	{
		freq = SI5351_MULTISYNTH_MIN_FREQ * SI5351_FREQ_MULT;
	}

	if(Si5351__pll_freq == 0)
	{
		// Find largest integer divider for max
		// VCO frequency and given target frequency
		lltmp = (SI5351_PLL_VCO_MAX * SI5351_FREQ_MULT) - 100000000UL; // margin needed?
		do_div(lltmp, freq);
		a = (uint32_t)lltmp;

		// Divisor has to be even
		if(a % 2 != 0)
		{
			a++;
		}

		// Divisor bounds check
		if(a < SI5351_MULTISYNTH_A_MIN)
		{
			a = SI5351_MULTISYNTH_A_MIN;
		}
		if(a > SI5351_MULTISYNTH67_A_MAX)
		{
			a = SI5351_MULTISYNTH67_A_MAX;
		}

		Si5351__pll_freq = a * freq;

		// PLL bounds checking
		if(Si5351__pll_freq > (SI5351_PLL_VCO_MAX * SI5351_FREQ_MULT))
		{
			a -= 2;
			Si5351__pll_freq = a * freq;
		}
		else if(Si5351__pll_freq < (SI5351_PLL_VCO_MIN * SI5351_FREQ_MULT))
		{
			a += 2;
			Si5351__pll_freq = a * freq;
		}

		reg->p1 = (uint8_t)a;
		reg->p2 = 0;
		reg->p3 = 0;
		return Si5351__pll_freq;
	}
	else
	{
		// Multisynth frequency must be integer division of PLL
		if(Si5351__pll_freq % freq)
		{
			// No good
			return 0;
		}
		else
		{
			a = Si5351__pll_freq / freq;

			// Division ratio bounds check
			if(a < SI5351_MULTISYNTH_A_MIN || a > SI5351_MULTISYNTH67_A_MAX)
			{
				// No bueno
				return 0;
			}
			else
			{
				reg->p1 = (uint8_t)a;
				reg->p2 = 0;
				reg->p3 = 0;
				return 1;
			}
		}
	}
}

void Si5351__update_sys_status(struct Si5351Status *status)
{
  uint8_t reg_val = 0;

  reg_val = Si5351_read(SI5351_DEVICE_STATUS);

  // Parse the register
  status->SYS_INIT = (reg_val >> 7) & 0x01;
  status->LOL_B = (reg_val >> 6) & 0x01;
  status->LOL_A = (reg_val >> 5) & 0x01;
  status->LOS = (reg_val >> 4) & 0x01;
  status->REVID = reg_val & 0x03;
}

void Si5351__update_int_status(struct Si5351IntStatus *int_status)
{
  uint8_t reg_val = 0;

  reg_val = Si5351_read(SI5351_INTERRUPT_STATUS);

  // Parse the register
  int_status->SYS_INIT_STKY = (reg_val >> 7) & 0x01;
  int_status->LOL_B_STKY = (reg_val >> 6) & 0x01;
  int_status->LOL_A_STKY = (reg_val >> 5) & 0x01;
  int_status->LOS_STKY = (reg_val >> 4) & 0x01;
}

void Si5351__ms_div(enum si5351_clock clk, uint8_t r_div, uint8_t div_by_4)
{
	uint8_t reg_val=0;
	uint8_t reg_addr=0;

	switch(clk)
	{
		case SI5351_CLK0:
			reg_addr = SI5351_CLK0_PARAMETERS + 2;
			break;
		case SI5351_CLK1:
			reg_addr = SI5351_CLK1_PARAMETERS + 2;
			break;
		case SI5351_CLK2:
			reg_addr = SI5351_CLK2_PARAMETERS + 2;
			break;
		case SI5351_CLK3:
			reg_addr = SI5351_CLK3_PARAMETERS + 2;
			break;
		case SI5351_CLK4:
			reg_addr = SI5351_CLK4_PARAMETERS + 2;
			break;
		case SI5351_CLK5:
			reg_addr = SI5351_CLK5_PARAMETERS + 2;
			break;
		case SI5351_CLK6:
			reg_addr = SI5351_CLK6_7_OUTPUT_DIVIDER;
			break;
		case SI5351_CLK7:
			reg_addr = SI5351_CLK6_7_OUTPUT_DIVIDER;
			break;
	}

	reg_val = Si5351_read(reg_addr);

	if(clk <= (uint8_t)SI5351_CLK5)
	{
		// Clear the relevant bits
		reg_val &= ~(0x7c);

		if(div_by_4 == 0)
		{
			reg_val &= ~(SI5351_OUTPUT_CLK_DIVBY4);
		}
		else
		{
			reg_val |= (SI5351_OUTPUT_CLK_DIVBY4);
		}

		reg_val |= (r_div << SI5351_OUTPUT_CLK_DIV_SHIFT);
	}
	else if(clk == SI5351_CLK6)
	{
		// Clear the relevant bits
		reg_val &= ~(0x07);

		reg_val |= r_div;
	}
	else if(clk == SI5351_CLK7)
	{
		// Clear the relevant bits
		reg_val &= ~(0x70);

		reg_val |= (r_div << SI5351_OUTPUT_CLK_DIV_SHIFT);
	}

	Si5351_write(reg_addr, reg_val);
}

uint8_t Si5351__select_r_div(uint64_t *freq)
{
	uint8_t r_div = SI5351_OUTPUT_CLK_DIV_1;

	// Choose the correct R divider
	if((*freq >= SI5351_CLKOUT_MIN_FREQ * SI5351_FREQ_MULT) && (*freq < SI5351_CLKOUT_MIN_FREQ * SI5351_FREQ_MULT * 2))
	{
		r_div = SI5351_OUTPUT_CLK_DIV_128;
		*freq *= 128ULL;
	}
	else if((*freq >= SI5351_CLKOUT_MIN_FREQ * SI5351_FREQ_MULT * 2) && (*freq < SI5351_CLKOUT_MIN_FREQ * SI5351_FREQ_MULT * 4))
	{
		r_div = SI5351_OUTPUT_CLK_DIV_64;
		*freq *= 64ULL;
	}
	else if((*freq >= SI5351_CLKOUT_MIN_FREQ * SI5351_FREQ_MULT * 4) && (*freq < SI5351_CLKOUT_MIN_FREQ * SI5351_FREQ_MULT * 8))
	{
		r_div = SI5351_OUTPUT_CLK_DIV_32;
		*freq *= 32ULL;
	}
	else if((*freq >= SI5351_CLKOUT_MIN_FREQ * SI5351_FREQ_MULT * 8) && (*freq < SI5351_CLKOUT_MIN_FREQ * SI5351_FREQ_MULT * 16))
	{
		r_div = SI5351_OUTPUT_CLK_DIV_16;
		*freq *= 16ULL;
	}
	else if((*freq >= SI5351_CLKOUT_MIN_FREQ * SI5351_FREQ_MULT * 16) && (*freq < SI5351_CLKOUT_MIN_FREQ * SI5351_FREQ_MULT * 32))
	{
		r_div = SI5351_OUTPUT_CLK_DIV_8;
		*freq *= 8ULL;
	}
	else if((*freq >= SI5351_CLKOUT_MIN_FREQ * SI5351_FREQ_MULT * 32) && (*freq < SI5351_CLKOUT_MIN_FREQ * SI5351_FREQ_MULT * 64))
	{
		r_div = SI5351_OUTPUT_CLK_DIV_4;
		*freq *= 4ULL;
	}
	else if((*freq >= SI5351_CLKOUT_MIN_FREQ * SI5351_FREQ_MULT * 64) && (*freq < SI5351_CLKOUT_MIN_FREQ * SI5351_FREQ_MULT * 128))
	{
		r_div = SI5351_OUTPUT_CLK_DIV_2;
		*freq *= 2ULL;
	}

	return r_div;
}

uint8_t Si5351__select_r_div_ms67(uint64_t *freq)
{
	uint8_t r_div = SI5351_OUTPUT_CLK_DIV_1;

	// Choose the correct R divider
	if((*freq >= SI5351_CLKOUT67_MIN_FREQ * SI5351_FREQ_MULT) && (*freq < SI5351_CLKOUT67_MIN_FREQ * SI5351_FREQ_MULT * 2))
	{
		r_div = SI5351_OUTPUT_CLK_DIV_128;
		*freq *= 128ULL;
	}
	else if((*freq >= SI5351_CLKOUT67_MIN_FREQ * SI5351_FREQ_MULT * 2) && (*freq < SI5351_CLKOUT67_MIN_FREQ * SI5351_FREQ_MULT * 4))
	{
		r_div = SI5351_OUTPUT_CLK_DIV_64;
		*freq *= 64ULL;
	}
	else if((*freq >= SI5351_CLKOUT67_MIN_FREQ * SI5351_FREQ_MULT * 4) && (*freq < SI5351_CLKOUT67_MIN_FREQ * SI5351_FREQ_MULT * 8))
	{
		r_div = SI5351_OUTPUT_CLK_DIV_32;
		*freq *= 32ULL;
	}
	else if((*freq >= SI5351_CLKOUT67_MIN_FREQ * SI5351_FREQ_MULT * 8) && (*freq < SI5351_CLKOUT67_MIN_FREQ * SI5351_FREQ_MULT * 16))
	{
		r_div = SI5351_OUTPUT_CLK_DIV_16;
		*freq *= 16ULL;
	}
	else if((*freq >= SI5351_CLKOUT67_MIN_FREQ * SI5351_FREQ_MULT * 16) && (*freq < SI5351_CLKOUT67_MIN_FREQ * SI5351_FREQ_MULT * 32))
	{
		r_div = SI5351_OUTPUT_CLK_DIV_8;
		*freq *= 8ULL;
	}
	else if((*freq >= SI5351_CLKOUT67_MIN_FREQ * SI5351_FREQ_MULT * 32) && (*freq < SI5351_CLKOUT67_MIN_FREQ * SI5351_FREQ_MULT * 64))
	{
		r_div = SI5351_OUTPUT_CLK_DIV_4;
		*freq *= 4ULL;
	}
	else if((*freq >= SI5351_CLKOUT67_MIN_FREQ * SI5351_FREQ_MULT * 64) && (*freq < SI5351_CLKOUT67_MIN_FREQ * SI5351_FREQ_MULT * 128))
	{
		r_div = SI5351_OUTPUT_CLK_DIV_2;
		*freq *= 2ULL;
	}

	return r_div;
}

